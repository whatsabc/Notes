# 1 计算机系统概论

## 1.1 计算机的发展

## 1.2 计算机的硬件组成

### 1.2.1 计算机的硬件框图

冯·诺伊曼计算机的特点是：
1. 程序以二进制代码的形式储存在储存器中
2. 所有的指令都是由操作码和地址码组成
3. 指令在其储存过程中按照执行的顺序
4. 以运算器和控制器作为计算机结构的中心
> 扩展笔记
```
1. 指令周期
取指    T
执行    n*T
IT=T+n*T

2.重要的寄存器
1.PC/IP
2.IR
3.AR
4.DR

3.机器周期（时间分配单位）
【8086指令一定是机器周期的整数倍】

4.eg:
2000H:ADD AC,[3000H]
=>机器指令格式

操作码 地址码
OPC    OPA

（1）取指周期：
PC->AB（地址总线）->M
M读出I->DB（数据总线）->IR
（2）取数周期：
CU分析IR中指令的操作码  OD2->AR->M
M读出D->DB（数据总线）->DR
（3）计算周期：
ALU（算数逻辑运算单元）
DR->ALU,AX->ALU,+
ALU->AX

5.机器周期的种类：
①取指周期 [PC]->IR
②取数周期 [AR]->DR
③写数周期 DR->[AR]
④非访存周期
```
### 1.2.2 计算机系统的主要技术指标

#### 1.机器字长

通常计算机的数据总线和寄存器的位数与机器字长一致

机器字长将直接影响ALU，数据总线，以及储存字长的位数
> TIPS
>
> 地址总线 (Address Bus；又称：位址总线) 属于一种电脑总线 （一部份），是由CPU或有DMA能力的单元，用来沟通这些单元想要存取（读取/写入）电脑内存元件/地方的实体位址，地址总线（Address Bus）是一种计算机总线，是CPU或有DMA能力的单元，用来沟通这些单元想要访问（读取/写入）计算机内存组件/地方的物理地址。
>
> 总线（Bus）是指计算机组件间规范化的交换数据（data）的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。从另一个角度来看，如果说主板（Mother Board）是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的比特（bit）。这些线路在同一时间内都仅能负责传输一个比特。因此，必须同时采用多条线路才能发送更多数据，而总线可同时传输的数据数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。总线的带宽（即单位时间内可以传输的总数据数）为：总线带宽=频率×宽度（Bytes/sec）

#### 2.主频

主频又称为时钟频率[f]，CPU工作的节拍是由时钟控制的

时钟周期([t]=1/f)-->节拍-->1/4机器周期-->指令周期，是CPU时间分配的最小单位

#### 3.储存容量

#### 4.运算速度
1. CPU执行速度


大多数计算机的时钟速度是固定的，其运行周期称为时钟周期。一个程序所消耗的CPU时间可以用两种方式来表示
```
CPU执行时间=CPU时钟周期数/频率
CPU执行时间=CPU时钟周期数*时钟周期长度
```

2. 平均运行时钟周期数（CPI）

```
CPI=CPU时钟周期数/IC
```

由此可知CPU执行时间的另一表达式：

```
CPU执行时间=CPI*IC*时钟周期长度
```
上式被称为CPU性能公式：（时钟频率取决于计算机组成和实现技术，平均运行时钟周期数CPI取决于计算机指令集的结构，设计及实现技术，指令集IC取决于指令集的结构以及编译技术）

3. MIPS和MFLOPS


MIPS（Million Instruction Per Second）它表示每秒百万条指令数。这是一个用来描述计算机性能的尺度
```

```
显然，机器愈快其MIPS愈高，愈小。但是MIPS有三个方面的缺陷：

- MIPS依赖于指令集，所以用MIPS来比较指令集不同的机器的性能好坏是很不准确的。
- 在同一台机器上，MIPS因程序不同而变化，有时是很大的。
- MIPS可能与性能相反

典型例子就是具有可选硬件浮点运算部件的机器。因为浮点运算远慢于整数运算，所以很多机器提供了可选的硬件浮点运算部件，但是软件实现浮点运算的MIPS 高，然而硬件实现浮点运算的时间少，这时MIPS与机器性能恰好相反。类似的情况在具有优化功能的编译器中也有发生。

另外，在使用MIPS时应注意它的应用范围，它只适宜于评估标量机，因为在标量机中执行一条指令，一般可得到一个运算结果，而向量机中，执行一条向量指令通常可得到好多个运算结果，因此，用MIPS来衡量向量机是不合适的。在MIPS中，不光是运算指令，所有的服务性指令，如取数、存数、转移等都计算在内，而在浮点运算中服务性指令均不予计入

另一个替代标准是MFLOPS（Million Floating Point Operation Per Second） ，它表示每秒百万次浮点操作次数。

MFLOPS可用如下式子表示：

```

```
显然，MFLOPS 取决于机器和程序两个方面。所以 MFLOPS只能用来衡量机器浮点操作的性能，而不能体现机器的整个性能。例如编译程序，不管机器性能有多好，它的 MFLOPS 不会太高

## 1.3 计算机系统的层次结构

### 1.3.1 计算机硬件

### 1.3.2 计算机软件

### 1.3.3 计算机系统的层次结构简介

### 1.3.4 计算机的工作过程

#### 1.主存储器

MAR 储存器地址寄存器，用来存放欲访问的存储单元的地址，其位数对应存储单元的个数（如MAR是10位，则有2^10=1024个存储单元，1K）

MDR 存储器数据寄存器，用来存放从存储体单元取出的代码或者准备往某存储单元存入的代码，其位数与存储字长相等。

#### 2.控制器

取指，分析和执行3个阶段

控制器由程序计数器PC，IR，CU几个部分组成，

#### 3.运算器

运算器包括3个寄存器（累加器ACC，乘商寄存器MQ，操作数寄存器X，现代计算机内部往设有通用寄存器组）和一个算术逻辑单元AUL

不同机器的运算器结构是不同的，图1.5所示的运算器可将运算结果从ACC保存至存储器的MDR，而存储器的操作数也可以从他的MDR保存至运算器中的ACC，AQ或X，有的机器还用MDR代替X寄存器。

#### 4.I/O系统

I/O系统包括各种外设及相应的接口。每种接口都由I/O接口与主机联系，它接受控制单元CU发出的各种控制命令，完成相应的操作。

# 2 运算器与方法器

## 2.1 数据的表示方法

### 2.1.1 进位计数制及其相互转换

#### 1.进位计数值

#### 2.进制之间的转换

### 2.1.2 真值和机器数

在计算机中参与运算的数有两大类：无符号数和有符号数

#### 1.无符号数

#### 2.有符号数

1. 机器数与真值

例如，真值+1011100的机器数表示为01011100

真值-1011100的机器数表示为11011100，由于符号位占用了一个bit，所以当机器字长相同时，无符号数和有符号数表示的范围是不同的。

2. 原码
3. 补码

正数的补码与原码相同，负数的补码是原码数值位按位取反再加1

4. 反码

正数的反码与原码相同，负数的反码是在原码的基础上，符号位不变，数值位按位取反

5. 移码

移码只用于整数的编码，小数没有移码表示法

从移码的定义来看，移码就是将补码的符号位取反

### 2.1.3 十进制数的二进制编码

#### 1.BCD码

#### 2.十进制数串的表示方法

### 2.1.4 字符和字符串

#### 1.ASCII码和EBCDIC码

#### 2.字符串的表示

字符串是指连续的一串字符，通常情况下，每个字符占用一个字节，从而占用主存中连续的多个字节，当主存字由两个或者四个字节组成时，在同一个主存字中，既可以按从低位字节向高位字节的顺序存放字符串的内容，也可以按从高位字节向低位字节的顺序存放字符串的内容。

#### 3.中文的编码方式

1. 汉字的输入编码

- 数字编码
- 拼音码
- 字形码

2. 国标码：国标码规定，一个汉字用两个字节表示，每个字节只使用低7位，最高位未作定义。为了方便书写，常用4位16进制来表示一个汉字。

3. 汉字机内码
4. 汉字字模码

## 2.2 数的定点表示和浮点表示

### 2.2.1 定点数

小数点固定在某个位置上的数称为定点数，根据小数点的具体位置，可分为定点小数和定点整数。

1. 定点小数：定点小数是把小数点固定在数据数值部分的左边，符号位的右边，记作X0.X1X2X3...XN，这个数是纯小数，小数点位置是隐含的，设机器字长为n+1位，则原码定点小数的表示范围是-(1-2^-n)---(1-2^-n)；补码定点小数表示范围是-1---(1-2^-n)
2. 定点整数：定点整数是把小数点固定在数据数值部分的右边，记作X0X1X2...XN，这个数是纯整数，设机器字长为n+1位，则原码定点整数的表示范围是-(2^n-1)---(2^n-1)；补码定点整数的表示范围是-2^n---(2^n-1)

### 2.2.2 浮点数

浮点数是指小数点位置可以浮动的数据，通常表示如下：

N=M*R^E

其中，N是浮点数，M是位数，E是阶码，R是阶的基数（底），而且R为一常数（与尾数的基数相同），一般为2，8，16.在一台计算机中，所有数据的R都是相同的，因此不需要在每个数据中表示出来

#### 1.浮点数的机内表示

#### 2.浮点数的表示范围

#### 3.浮点数的规格化

当基数为2而且尾数不为0时，若采用补码表示形式，规格化小数的具体表现形式为0.1\*\*\*（正数）和1.0\*\*\*（负数），即符号位与最高数值位相异，若采用原码表示，无论正负，都要求尾数的最高数值位为1

在规格化过程中，尾数每向左移一位，阶码减1，称为向左规格化，简称左规，尾数每向右移，阶码加1，称为向右规格化，简称右规。

## 2.3 定点数的移位运算

## 2.4 定点数的加减运算

### 2.4.1 补码的加减运算及溢出判断

#### 1.补码的加减运算

有如下重要结论：

1. 补码运算后仍然是补码
2. 符号位和数值位一样参与运算

#### 2.溢出判断

两正数相加，结果为负数，为正溢，两负数相加，结果为正，表示负溢。

1. 符号比较法

符号相同的两个数相加，结果与这两个数不同，溢出。

2. 双进位法

任意符号的两个数相加，如果C=Ci，运算结果正确，其中，C为数值最高位的进位，Ci为符号位的进位，如果C不等于Ci，溢出，Ci=0/C=1表示正溢，Ci=1/C=0表示负溢

3. 双符号位法

正数的符号位是00，负数是11，记为Fs2，Fs1

结果为01，正溢，结果为10，负溢，无论是否溢出，Fs2永远代表正确的符号位

### 2.4.2 移码的加减运算及溢出判断

使用双符号位的加法器，规定移码的第二个符号位，即最高符号位恒为0参加加减运算，溢出条件是结果的最高符号位为1，此时，当低符号位为0，表示结果正溢，当低符号位为1，表示结果负溢

当最高符号位为0，表示没有溢出，此时，低符号位为1，表示结果为正，低位符号位为0时，表示结果为负。

## 2.5 加法器和算数逻辑单元

### 2.5.1 加法器

#### 1.半加器

#### 2.一位全加器

#### 3.串行多位加法器

#### 4.超前进位加法器

### 2.5.2 算术逻辑单元

## 2.6 定点乘法运算

### 2.6.1 定点原码一位乘

### 2.6.2 补码一位乘

#### 1.校正法

#### 2.比较法

### 2.6.3 原码两位乘

### 2.6.4 补码两位乘

### 2.6.4 阵列乘法器

## 2.8 浮点运算

### 2.8.1 浮点数的加减法运算

1. 对阶

对阶规则是小阶向大阶对齐，也就是说，Ex=Ey的时候，无须对阶，若Ex>Ey，则My右移，每右移一位，Ey加1，直到Ex等于Ey为止

尾数右移后，最低有效位丢失，考虑到在后续操作中，尾数还有可能进行左移或右移操作，为了减少整体误差，先存储运算过程中右移出来的位，最后进行舍入操作

2. 尾数相减
3. 规格化

- 如果结果两个符号位的值不同，表明尾数结果溢出，此时双符号位的低位实际上是数值位，高位表示正确的符号位，因此将尾数右移一位，恢复正常，同时阶码加1，称为向右规格化，简称右规
- 如果结果两个符号位的值相同，表示尾数结果不会溢出，根据补码形式下的规格化特点，最高数值位与符号位总是相反的，因此，若最高数值位与符号位相同，则尾数连续左移，直到最高数值位与符号位的值不相同为止，，同时从E中减去移位的位数，称为“向左规格化”，简称左规

4. 舍入

在对阶及右规的过程中，尾数低位上的数值会移出，如果直接做截断处理，即无条件丢弃所有移出的位，精度会有很大的影响，有如下两种舍入处理方式：

- 0舍1入法，当移出的最高位是0时，直接舍去，移出的最高位为1时，在尾数的末尾加1，如果加1后又导致尾数溢出，则需要再次进行右规
- 若移出的位中包含1，就将尾数的最低为置为1，否则尾数的最低位保持不变。为处理简单，还可以采用最低为恒置为1的方法

5. 判溢出

处理过程中会对阶码进行加减运算，有可能造成阶码的溢出，即浮点数的溢出，在浮点数的加减运算后要对阶码是否溢出进行判断，若未溢出，运算正常，若阶码下溢，则将结果置为机器零，若上溢，则置溢出标志。

### 2.8.2 浮点数的乘除法运算

两个浮点数相乘，乘积的阶码为两数阶码之和，尾数是两数尾数之积。完成操作后，同样要对结果进行规格化，舍入，判溢出等操作，这些步骤的操作过程与浮点数加减法中对应的步骤类似

#### 1. 浮点数的乘法步骤

1. 阶码相加
2. 尾数相乘
3. 结果规格化
4. 舍入
5. 判溢出

#### 2. 浮点数的除法步骤

1. 阶码相减
2. 尾数相除
3. 结果规格化
4. 舍入
5. 判溢出

## 2.9 运算器的基本结构

### 2.9.1 定点运算部件

### 2.9.2 浮点运算部件

### 2.9.3 定点运算器的基本结构

#### 1.单总线结构的运算器

#### 2.双总线结构的运算器

#### 3.三总线结构的运算器

## 2.10 数据校验码

### 2.10.1 基本概念

### 2.10.2 奇偶校验码

奇偶校验码可以发现一位出错的情况

当D中含有偶数个1时，D奇 为1，当D中含有及奇数个1时，D奇 为0，因此数据D与校验位D奇 构成的码字中必然包含奇数个1

如果传输正确则F=0，若有奇数位出错则F=1

### 2.10.3 海明校验码

能检测一位和两位错，并且能实现一位自动纠错

它在k位数据中加入了r个校验位，形成了一个k+r位的新码字，并且将数据的每个二进制位分配到几个不同的奇偶校验组中，这样，当其中一位发生变化时，就会引起有关的几个组出现奇偶校验错，通过这些出错组的不同组合，就能够指明到底是哪一位出现了错误，从而进行纠错。

使用海明码进行校验，首先需要确定校验码的位数，当海明码性能不同时，k位数据所需要的校验码的位数r也不相同

- 海明码只能进行一位校验检错，而不能实现两位检错，此时r位校验位能够表示2^r种不同的状态。为了实现一位检错纠错，需要用一种状态表示信息正确，用k+r种状态表示k位数据和r位校验位中的每一位出错，一共k+r+1种状态，因而要求：2^r>=k+r+1
- 若海明码不仅能够实现一位检错纠错，还能实现两位检错，则需要在校验位中使用一位表示不出错/偶数位出错或者奇数位出错，配合用剩下的r-1位的2^(r-1)个状态分别表示k位数据和r位校验位中的哪一位出错（一位错），因此有2^(r-1)>=k+r

设数据位为D，共k位，记为Dk...D1；校验位为P，共r位，记为Pr...P1；编码所得的海明码为H，共m位，记作Hm...H1，显然有m=k+r，且位号1表示最低位，此海明码的编码规则通常是：

- 每个校验位Pi在海明码H中被分配在位号2^(i-1)的位置，H中的空余位上放置数据位，并按从低到高的顺序逐位依次排序分配各数据位
- 海明码的每一位码Hi（包括数据位和校验位）由多个校验位校验，其作用是被校验的每一位的位号等于该校验位的各校验位的位号之和，这样安排的目的是希望校验的结果能正确反映出出错的位号

为了方便理解，设待校验的数据共8位，可知需要5位校验位，编码后的结果共13位，表示为H13H12H11...H1

根据规则，5位校验位P1-P5应该分别放置在H1 H2 H4 H8 H16上，但是因为H最多只有13位，所以将P5放置在H的最高位H13上，其它4位满足Pi的位号等于2^(i-1)的关系，剩余各位依次按序安排数据位Di

若S5 为1，表示奇数位出错，此时S4S3S2S1所对应的二进制数正是出错位的位号，若S5为0，此时S4-S1不全为0，则表示偶数位出错，若S4-S1全部为0，表示未出错，因此可以区分两位错或一位错

例如，S4S3S2S1=1100，表示H12出错

### 2.10.4 循环冗余校验码

CRC码是在k位数据位后面拼接r位校验位得到的，关键在于如何从k位数据位简便的得到r位校验位，以及接收方如何判断是否出错，为了解决这两个关键问题，首先引入CRC编码需要用到的模2运算

1. 模2运算

模2运算是指以按位模2相加为基础的四则运算，运算时不考虑进位和借位

- 模2加减：按位加，可用异或逻辑实现，即0±0=0，0±1=1，1±1=0.注意两个结论，一是模2加与减的结果相同，二是两个相同的数据进行模2加时，其和为0
- 模2乘：按模2加求部分积之和
- 模2除：按模2减求部分余数，不借位，每求一位商应使部分余数减少1.上商的原则是：当部分余数的首位为1时，商1，当部分余数的首位为0时，商0；当部分余数的位数小于除数的位数时，该余数为最后余数，除法结束

> 使用模2除法计算1010101/1011

```

```

2. CRC码的编码

设有k位信息位Ck-1Ck-2...C1C0，可将其表示为如下的多项式M(x)，其中Ci等于0或者1

M(x)=Ck-1 x^(k-1)+Ck-2 x^(k-2)+...+Ci x^i+...+C1 x^1+C0

将信息左移r位，后面补上r个0，则对应的多项式操作为M(x) x^r，这样就可以空出r位，以便拼接r位校验位。即：
```
信息位组		k位
左移r位	    k位|r位
			  n=k+r位
```
利用系统给定的一个多项式G(x)，使用模2运算。用多项式M(x)\*x^r除以G(x)，所得的余数即是所求的校验位，容易看出，为了保证余数（校验位）是r位，G(x)必须是r+1位。G(x)称为生成多项式，用于产生校验码。

设所得余数表达式为R(x)，商为Q(x)，将余数拼接在信息位左移后空出的r位上，就构成这个有效性息位的CRC码。

3. CRC码的译码与纠错

根据前面的分析，CRC码可以被G(x)表示的数除尽。显然，如果传输正确，此特性应当继续保持。因此目标方将收到的循环冗余校验码用双方共同约定的生成多项式G(x)去做模2除，如果码字无误，则余数应为0，如果某一位出错，则余数不为0，且当不同位出错时，余数均不相同，从而为纠错提供依据。

通过选择合适的生成多项式，能够保证余数和出错位对应关系不变，只与码制和生成多项式有关。

4. 关于生成多项式

并不是任何一个r+1位的多项式都可以作为生成多项式的，从检错及纠错的要求出发，生成多项式应该能满足下列要求：

- 任何一位发生错误都应该使余数不为0
- 不同位发生错位余数应该不同
- 对余数继续做模2除，应该使余数循环

# 3 存储系统

## 3.1 存储系统概述

### 3.1.1 存储器分类

按照存储介质分类：分为半导体存储器和磁表面存储器

按照存储方式分类：分为随机存储器和顺序存储器

按照读写功能分类：只读存储器ROM和随机读写存储器RAM

按照存储器的可保存性分类：非永久记忆型存储器和永久记忆型存储器

在计算机系统中起到的作用：主存储器，辅助存储器，高速缓冲存储器，控制存储器，主存储器简称主存，又称为内存。辅助存储器又称为外存（硬盘，软盘，闪存）

### 3.1.2 主存储器的主要性能指标

1. 存储容量
2. 存取时间

分为读出时间和写入时间，读出时间是指从CPU向存储器发出有效地址和读命令开始，直到将被选单元的内容读出所用的时间，写入时间是指从CPU向存储器发出有效地址和写命令开始，直到信息被写入选中单元为止所用的时间

3. 存储周期

又称为读/写周期或访问周期，是指CPU连续启动两次独立的存取操作所需间隔的最短时间，时间上略大于存取时间，单位为ns

### 3.1.3 存储系统的层次结构

1. 主存与辅存之间的关系

弥补主存容量的不足

2. 主存和高速缓存之间的关系

为了解决CPU和主存之间的速度差距，提高整机的运算速度，在CPU和主存之间增加一级或两级速度高，容量较小而且每位价格高的高速缓存存储器Cache。

## 3.2 主存储器

### 3.2.1 静态存储器SRAM

1. 存储体
2. 地址译码器
3. 驱动器
4. I/O电路
5. 片选与读/写控制电路
6. 输出电路

### 3.2.2 动态存储器DRAM

#### 1.存储元和存储器原理

1. 三管
2. 单管

#### 2.再生

### 3.2.3 RAM芯片实例

### 3.2.4 存储控制

1. 集中刷新

例如，一个存储器有1024行，系统工作周期是200ns，DRAM的刷新周期是2ms，这样，在每个刷新周期内共有10000个工作周期，其中，用于再生的为1024个工作周期，读写的是8976个工作周期。集中刷新的缺点就是在刷新期间不能访问存储器，有时会影响计算机系统的正常工作

1. 分布式刷新

把刷新分散到刷新周期2ms内，每隔一段时间刷新一行

假设有128行，则2ms/128=15.6μs，每隔15.6μs提一次刷新请求，刷新一行；2ms内刷新完所有行

### 3.2.5 DRAM与SRAM的比较

DRAM：一个DRAM需要使用大概一个晶体管和一个电容，读写速度教慢，需要配备再生电路，一般用作主存

SRAM：一个SRAM需要6个或者8个晶体管，读写速度较快，内部采用双稳态触发器来存储数据，电路结构复杂，成本高，一般用作CPU内部的一级，二级缓存。

## 3.3 半导体存储器的容量扩展

1. 位扩展

在位数上进行扩展，使每个存储单元的字长增加，但是存储单元的数量不变

2. 字扩展

在字向上进行扩展，增加存储单元的数量

3. 字位扩展

## 3.4 双端口存储器和多体交叉存储器

### 3.4.1 双端口存储器

双端口存储器是指在同一个存储器具有两组相互独立的读写控制线路，并进行并行的独立操作，是一种高速工作的存储器。

### 3.4.2 多体交叉存储器

## 3.5 高速缓冲存储器

### 3.5.1 Cache的基本工作原理

### 3.5.2 Cache地址映像

#### 1.直接映像

直接映像函数可以定义为：b=Bmod2^c

其中，b为Cache的字块号，B为主存的字块号，c为Cache块号编址长度。例如Cache共4块，则c=2，主存块号为6对应于Cache的2块。在这种映像方式中，主存的第0块，第2^c块，第2^(c+1)块，...只能映像到Cache的第0块；主存的第1块，第2^c+1块，第2^(c+1)+1块，...只能映像到Cache的第1块；

通常情况下，按照Cache存储器的大小，对主存储器进行分区，主存每个区的块号与Cache的块号一一对应，因此，主存储器的地址由三部分构成

```
区块号E	块号B		块内地址W
```

主存地址末l位是字块内地址，称为字地址；中间c位是Cache字块地址，称为块地址；高t位是主存字块标记，称为区地址。

直接映像的优点是实现简单，缺点是不够灵活，即主存2^t个字块只能对应唯一一个Cache字块，即使其他Cache字块均为空，也得不到利用，因此降低了Cache的访问命中率。

#### 2.全相联映像

#### 3.组相联映像

### 3.5.3 Cache替换算法

#### 1.先进先出算法

#### 2.许久未用算法

### 3.5.4 Cache性能分析

#### 1.Cache命中率

假设Cache的访问周期是TC，主存储器的访问周期是TM，Cache系统的等效访问周期是T，Cache的命中率为H，并采用无论是否命中均同时查找Cache和主存，即认为查找Cache的时间为查找主存时间的一部分，则有如下关系：

```
T=H*TC+(1-H)*TM
```

1. Cache命中率与容量的关系

Cache命中率随容量S的增加而提高，在Cache容量很小的时候，命中率提高的很快，随着容量的增加，命中率的提高速度逐渐降低，当Cache容量增加到无穷大的时候，命中率可望达到100%，但实际是达不到的。

2. Cache命中率与块大小的关系

在采用组相联映像方式的Cache中，当容量一定时，块的大小对命中率的影响非常敏感，块很小时，命中率很低，随着块的增大，命中率增加，当在某一最佳块大小处达到最大值后，随着快的增大，命中率反而下降。

3. Cache命中率与组数的关系

当Cache容量一定的时候，采用组相联映像方式，分组的数目对于命中率的影响很明显。随着组数的增加，Cache命中率逐渐降低。因为采用组相联映像方式，组件是采用直接映像的方式，只有组内采用全相联映像方式，当分组数目增加，组内的块数减少，那么主存的某一块可以映像到的Cache的块数就减少了，从而导致命中率下降。

#### 2.Cache的一致性问题

正常情况下，Cache存储器中存放的内容应该是主存储器的部分副本，然而，由于以下两个原因，造成一段时间内主存某单元中的内容与Cache对应单元中的内容可能不是相同的，这种情况被称为Cache与主存的不一致问题。

1. 由于CPU执行写操作，直接将Cache中的内容从C1修改成了C2，而主存对应单元的内容还是C1，没有改变
2. 由于输入输出处理机或输入输出设备写新数据到主存储器，修改了主存单元的内容，将C1修改成了C2，而Cache对应单元中的内容还是C1，没有改变

一般更新Cache的算法有两种：

1. 写直达法：CPU在执行写操作的时候，必须将数据同时写入Cache和主存
2. 写回法：在CPU在执行写操作的时候，数据只写入Cache，不写入内存。只有当需要将该数据所在块替换出Cache的时候，才会将修改过的Cache块整块写回到主存。该算法允许主存与CPU存在不一致的情况发生，但同样可以解决不一致造成的问题，此种算法需要在Cache块表中保留“修改”标志位。如果对该块单元进行了修改，则该标志位置1否则为0.当该数据所在块置换出Cache时，需要根据“修改”标志位的值决定是否写回主存。

# 4 指令系统

## 4.1 指令的组成

指令一般由操作码和地址码两部分构成
```
操作码 OPC 地址码 A
```
## 4.2 寻址技术

形式地址：经过一定的计算可以得到有效地址

有效地址：有效地址通过与所在段的段地址综合，可以得到直接访问主存储器的物理地址，一旦程序装入内存，段地址就是确定的，可以看出有效地址即为段内偏移地址

物理地址：

### 4.2.1 立即寻址方式
立即数就在指令中，这种寻址方式叫做立即寻址方式

例如
```assembly
MOV AL,6H
```
需要注意的是，立即数的类型必须与目的操作数的类型一致，目的操作数是字节，立即数也必须是字节，或者两者都是字

### 4.2.2 寄存器寻址方式

与立即数寻址方式不同的是，立即数是指令的一部分，寄存器寻址方式中的操作数在CPU内部的寄存器中

```assembly
MOV AX,BX
```
> 以上两种寻址方式都不需要访问内存，以下都需要

### 4.2.3 直接寻址方式
- 1.储存器读操作
```assembly
MOV AX,DS:[4050H]
```
- 2.储存器写操作
```assembly
MOV DS:[4050H]，AX
```
CPU根据EA和段地址DS计算出物理地址后，再访问储存器取出操作数的数值
- 3.符号地址
直接寻址方式除了用数值作为有效地址外，还可以用符号地址的形式。
```assembly
VALUE DW 5678H
MOV AX,VALUE
MOV AX,[VALUE]
```
- 4.段前缀
关于内存有关的寻址方式中，操作数的段地址默认为数据段，如果操作数在其他段中存放，称为段超越，需要在指令中用段超越前缀指出，即用操作数前加上段寄存器和冒号来表示
```assembly
VALUE EQU 1000H
MOV AX,DS:[VALUE]
MOV BX,ES:[VALUE]
```

### 4.2.4 寄存器间接寻址

操作数的有效地址EA就在寄存器里面，这种寻址方式叫寄存器间接寻址。他把寄存器中的内容作为操作数的地址，而操作数还是在内存中。

需要注意的是，只允许BX BP SI DI
```assembly
MOV AX,[BX]
```
### 4.2.5 寄存器相对寻址

操作数的有效地址EA是个寄存器和位移量之和，这种寻址方式称为寄存器相对寻址。机寄存器同接寻址方式不同的是，有效地址EA的构成除了寄存器以外，还要加上位移量。这里允许的寄存器和默认段寄存器的规定与寄存集间接寻址方式中一样，默认指配也是DS段寄存器和BX、SI、DI，SS段寄存器和BP。

- 操作数的物理地址=(DS)x10H+(BX)+8位(16)位位移量
- 操作数的物理地址=(DS)x10H+(SI)+8位(16)位位移量
- 操作数的物理地址=(DS)x10H+(DI)+8位(16)位位移量
- 操作数的物理地址=(SS)x10H+(BP)+8位(16)位位移量
```assembly
MOV AX,TOP[SI]
```
这里TOP是符号地址，即位移量
```assembly
MOV [BX+2623H],AX
或写成MOV [BX].2623H,AX
```
已知(DS)=1500H，(BX)=6854H，则有效地址EA=(BX)+2623H=8E77

物理地址=(DS)x10H+EA=15000H+8E77H=1DE77H

若(IDE77H)=3567H,执行指令后:(AX)=3567H

> 例4.13
```assembly
MOV AX,,ARRY[BX]
MOV AX,[ARRY][BX]
MOV AX,[ARRY+BX]
MOV AL,BUF[BX]
MOV AL,[BX+BH]
MOV AL,[BX].8H
```
前3条指令写法不同，但都是等效的。其中位移量ARRY,通常是16位的变量，因为要和16位的寄存器匹配。注意，这里源操作数的有效地址是由ARRY的偏移地址加上BX的值组成。ARRY也可以是常量，第4条指令中的BUF通常是8位的变量，也可以是常量。

寄存器间接寻址方式的用途:特别适用于访问一维数组，寄存器可作为数组下标(或数组元素的位置)，利用修改寄存器的值来定位数组中的各个元素。

### 4.2.6 基址变址寻址方式

操作数的有效地址是一一个基址寄在器和一个变址寄存器的内容之和，这种寻址方式称为基址变址寻址。允许使用的基址寄存器为BX和BP，变址寄存器为SI和DI，默认段寄存器的规定与寄存器间接寻址方式中一样。

- 操作数的物理地址=(DS)x10H+(BX)+(DI)
- 操作数的物理地址=(DS)x10H+(BX)+(SI)
- 操作数的物理地址=(SS)x10H+(BP)+(SI)
- 操作数的物理地址=(SS)x10H+(BP)+(DI)

```assembly
MOV AX,[BX+DI]
```
执行前:已知(DS)=2100H,(BX)=0158H,(DI)=10ASH,(221FD)=34H,(221FE)=95H,(AX)=0FFFFH。则

有效地址EA=(BX)+(DI)=0158H+10A5H=11FDH

物理地址=(DS)x10H+EA=21000H+11FDH=22IFDH

执行后，(AX)=9534H

```assembly
MOV AX,[BX][SI]  ;默认DS寄存器作段地址  
MOV AX,[BP][DI]  ;默认SS寄存器作段地址  
MOV AX,ES:[BX][DI]  ;指定ES寄存器作段地址  
MOV DX,[BP][SI]  ;默认SS寄存器作段地址  
MOV [BX+DI],CX  ;默认DS寄存器作段地址  
MOV [BP+SI],AL  ;默认SS寄存器作段地址
```

### 4.2.7 相对基址变址寻址方式

操作数的有效地址是一个基址寄存器和一个变址寄存器以及一个位移量之和，这种寻址方式称为相对基址变址寻址。它所允许使用的基址寄存器为BX和BP，变址寄存器为SI和DI。默认段寄存器的规定与寄存器间接寻址方式中一样。位移量可以是常量，也可以是符号地址。

- 操作数的物理地址=(DS)x10H+(BX)+(DI)+8位(16位)位移量
- 操作数的物理地址=(DS)x10H+(BX)+(SI)+8位(16位)位移量
- 操作数的物理地址=(SS)x10H+(BP)+(SI)+8位(16位)位移量
- 操作数的物理地址=(SS)x10H+(BP)+(DI)+8位(16位)位移量

```assembly
MOV AX,MASK[BX] [SI]  ;默认DS寄存器作段地址
MOV AX,[MASK+BX+SI] ;默认DS寄存器作段地址
MOV AX,[BX+SI]MASK ;默认DS寄存器作段地址
```
以上3种表示形式实现的功能是一样的

其有效地址EA=MASK+(BX)+(SD);

物理地址=(DS)X10H+EA。

这种寻址方式可用于二维数组的处理，数组的首地址为ARRY,基址寄存器指向数组的行，变址寄存器指向该行的某个元素。利用修改基址寄存器和变址寄存器的内容可以方便地访问数组中的各个元素。

## 4.3 指令的格式设计

### 4.3.1 操作码的编码方式

1. 固定长编码
2. Huffman编码
3. 扩展编码

### 4.3.2 地址码的编码设计

## 4.4 指令系统的功能

### 4.4.1 基本指令系统

1. 数据传送类指令
2. 运算类指令
3. 程序控制指令
4. 输入输出指令
5. 处理机控制和调试指令

### 4.4.2 复杂指令系统

### 4.4.2 精简指令系统

# 5 中央处理器

## 5.1 CPU的功能和基本结构

### 5.1.1 CPU的功能

1. 指令控制
2. 操作控制
3. 时间控制
4. 数据加工

前三个由控制器实现，第四个由运算器实现

### 5.1.2 CPU的组成

#### 1.运算器

运算器主要由算术逻辑单元，累加寄存器，数据缓冲寄存器和状态寄存器等组成

#### 2.控制器

### 5.1.3 CPU中主要的寄存器

CPU中必须有各类具备不同处理功能的逻辑部件配合工作，其中的一类的常用部件就是寄存器。CPU中的寄存器一般可分为通用寄存器和专用寄存器两大类

#### 1.通用寄存器

#### 2.专用寄存器

1. 程序计数器
2. 指令寄存器
3. 地址寄存器
4. 数据缓冲寄存器
5. 状态条件寄存器

### 5.1.4 CPU的基本模型

## 5.2 控制器的功能和组成

### 5.1.2 指令的执行步骤

一条指令的完整执行过程通常可分为读取阶段，分析取数阶段，和执行阶段

#### 1.读取阶段

#### 2. 分析取数阶段

#### 3.执行阶段

### 5.2.2 控制器的功能

控制器的功能主要包含如下三点：

1. 读取指令
2. 分析指令
3. 执行指令

除此之外，程序和数据要输入到机器中，运算结果要输出，机器运行过程中出现的一些异常情况和请求要进行处理，因此控制器还应该具有如下功能

1. 控制程序和数据的输入与结果输出
2. 对异常情况和某些请求的处理
   1. 中断请求信号
   2. DMA请求信号

### 5.2.3 控制器的组成

#### 1.程序计数器

#### 2.指令寄存器

#### 3.指令译码器

#### 4.地址形成部件

#### 5.脉冲源

#### 6.启停线路

#### 7.节拍信号发生器

#### 8.控制单元

#### 9.中断控制逻辑

### 5.2.4 控制器的硬件实现

#### 1.硬布线控制器

#### 2.微程序控制器

## 5.3 时序系统与控制方式

### 5.3.1 指令周期和机器周期

指令周期的长短通常用机器周期来衡量，机器周期也被称为CPU周期，通常用内存中读取一个指令字所需要的最短时间来规定机器周期。

取出指令需要占用一个单独的机器周期，指令周期至少需要两个机器周期，（取值周期，取数周期和执行周期）

### 5.3.2 节拍和脉冲

#### 1.节拍

机器周期并非是组织控制信号的最小单位，在一个机器周期中要完成一个相对独立的功能，这些功能是通过若干个操作来实现的，称为微操作。把一个机器周期分成若干个相等的时间段，每个时间段对应一个电位信号，称为节拍电位信号。一个节拍的宽度取决于CPU完成一次微操作所需要的事件。

不同机器周期所需要的节拍数不同。

1. 统一节拍法
2. 分散节拍法
3. 延长节拍法
#### 2.脉冲

#### 3.微型计算机中的处理程序

在微型计算机中，通常不再单独设置节拍，而是直接使用时钟型号。时钟信号的一次变化周期称为时钟周期，时钟信号的频率通常称为CPU频率
### 5.3.3 多级时序系统

### 5.3.4 控制器的控制方式

#### 1.同步控制方式

#### 2.异步控制方式

#### 3.联合控制方式

#### 4.人工控制方式

## 5.4 数据通路

## 5.5 微程序控制器

### 5.5.1 微程序控制器的基本概念

1. 微命令和微操作

构成控制序列的最小单位，执行部件接受微指令所执行的操作，称为微操作，因此可以将一条指令的执行过程分解为一个微操作序列。

微命令和微操作是一一对应的

2. 微指令和微程序

完成一条指令所需要的控制信号需要分批送出，同时发出一组微命令的集合就就形成微指令。

一条机器指令分成多步执行，每一步对应一条微指令，这些微指令的集合就构成了微程序，因此，每一条机器指令对应一段微程序。

3. 程序控制器
4. 微地址
5. 微指令寄存器
6. 微周期

### 5.5.3 微程序控制器

#### 1.控制存储器

控制存储器用来存放全部指令的所有微程序。

#### 2.微地址寄存器

微地址寄存器存放的是下一条待执行的微指令的微地址，即微指令在控制存储器中的存储位置

#### 3.微地址形成部件

#### 4.微指令寄存器

## 5.6 微程序设计技术

### 5.6.1 微命令的编码方式

1. 直接编码方式
2. 字段直接编译法
3. 字段间接编译法

### 5.6.2 微地址的形成方式
1. 计数器方式
2. 断定方式
3. 结合方式
### 5.6.3 微指令格式设计
1. 水平型微指令

水平型微指令是指能够在一条微指令中定义并执行多个并行微操作的微指令。前面介绍的直接控制法，字段直接编译法，字段间接编译法都属于水平型微指令

水平型微指令的并行操作能力强，效率高，灵活性强，执行一条机器指令时所需要的微指令数量少，执行速度快；但是在水平型微指令中，每条微指令的字长较长，要求设计者对机器的结构，数据通路，时序系统非常了解，才能编制出理想的微程序。

2. 垂直型微指令

垂直型微指令是指在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能，通常在一条垂直型微指令中只能实现1-2个微操作，控制1-2个信息传送通路，不强调并行控制。

# 6 输入输出系统

## 6.1 I/O接口

### 6.1.1 I/O接口的特点，分类，基本功能和结构

#### 1. I/O接口的特点和基本功能

1. I/O接口的特点
外设或者I/O设备与主机相比，有以下几个明显的特点
- 外设速度缓慢
- 外设的多样性和复杂性
计算机系统中，为了使各种外设和主机构成一个有机整体，至少需要做如下工作：
- 完成各种匹配
- 提高I/O系统的性能

2. I/O接口的基本结构
- 设备选择电路
- 命令寄存器
- 数据缓冲寄存器
- 设备状态标记

3. 输入输出接口类型

按照数据传送的宽度可以分为以下两类：
- 并行接口---设备和接口同时传送一个字节的所有位
- 串行接口---设备和接口的数据是逐位串行传送的，而接口和主机之间是按照字节或字并行传送，接口要完成数据格式的串-并转换

### 6.1.2 I/O端口及其编址

1. 独立编址方式

采用这种方式，主存单元和外设接口寄存器都是单独编址。通常，把外设接口寄存器的地址称为端口，存放数据的寄存器称为数据端口，存放控制命令或者状态的端口称为控制/状态端口

2. 统一编址方式

统一编址方式是利用访存指令完成I/O功能，使用这种主存地址空间中分出的一部分地址码作为I/O的设备代码。

一般来说，外设至少有两个寄存器：设备状态寄存器和数据缓冲寄存器

### 6.1.3 I/O设备数据传送控制方式

1. 程序直接控制方式

程序直接控制方式也称为程序查询方式，是通过程序来控制主机和外设的数据交换。

2. 程序中断传送方式

程序中断传送方式的基本思想是，当CPU进行输入输出时，先执行相应的I/O指令，将启动命令发送给相应的I/O接口和外设，然后CPU继续执行其他程序

3. 直接存储器存取方式

直接存储器方式主要用于高速设备和主机的数据传送，这类高速设备采用成批数据交换技术，而且单位数据之间的间隔较短。直接存储器存取方式需要用专门的硬件（DMA控制器）来控制总线进行数据交换

4. 通道控制与外围机处理方式

## 6.2 程序直接控制方式

## 6.3 程序中断方式

### 6.3.1 中断的基本概念

1. 中断源

除了各种I/O设备之外，还有其他许多突发性事件是引起中断的因素，为此，把凡是能向CPU提出中断请求的各种事件统称为中断源。

2. 禁止中断和中断允许

中断允许触发器控制

3. 中断响应

中断请求何时发生是随机的

4. 保护断点

当中断发生时，主程序的下一条指令地址为断点位置。保护断点，即将当前代码段寄存器CS，程序计数器PC，标志寄存器PSW的值入栈，以便在中断响应结束后可以按照断点的相关值返回到主程序中。

5. 中断向量

CPU响应中断后，必须由中断源提供中断服务程序入口地址信息，引导程序进入中断服务子程序，这些中断服务子程序的入口地址称为中断向量，一般将中断向量存放在中断向量表中。内存中专门开辟了一个区域，存放中断向量。

6. 向量中断和非向量中断

向量中断是指那些终端服务程序的入口地址是由中断事件自己提供的中断，中断事件在提出中断请求的同时，通过硬件向主机提供中断服务程序入口地址，即向量地址。

非向量中断的中断事件不能直接提供中断服务程序的入口地址

7. 中断优先级

多个中断请求时，中断系统判别中断申请的优先级

8. 单重中断和多重终端

多重中断在执行某个中断服务程序的过程中，CPU可去相应级别更高的中断请求，又称为多重嵌套中断。多重中断表征计算机中断功能的强弱。

9. 外部中断和内部中断

外部中断也称为硬件中断，是由外部的硬件产生的，硬件中断又分为不可屏蔽中断和可屏蔽中断。

对于不可屏蔽中断中断用户是不能用软件来屏蔽的，一旦有不可屏蔽中断请求，例如电源掉电，CPU必须予以相应。对于可屏蔽中断用户可以通过软件设置来屏蔽外部中断，即使外部设备中有中断请求，CPU可以不予响应。

内部中断又称为软件中断。软件中断通常由3中情况引起：中断指令INT引起的中断，由CPU的某些运算错误引起的中断，由调试软件Debug设置的中断。

### 6.3.2 中断处理

1. 中断处理过程

- 关中断，进入不可再次响应的状态，由硬件自动实现
- 保存断点和现场（软硬件两种方式）。为了在中断处理结束后能正确的返回到中断点，在响应中断时，必须进行断点保护。
- 判别中断源，转向中断服务子程序
- 开中断。开中断将允许更高级中断请求得到响应，实现中断嵌套。
- 执行中断服务子程序。不同中断源的中断服务子程序是不同的，实际有效的中断处理工作在此程序段实现
- 退出中断。在退出时，又进入不可中断状态，即关中断，恢复现场，恢复断点，然后开中断，返回原程序执行。

2. 中断嵌套

允许中断和禁止中断是由CPU中的中断允许触发器控制的，当中断允许触发器EINT被置为1，允许中断，置为0，禁止中断

允许中断即开中断，下列情况应该开中断

- 在中断服务程序执行完毕，恢复中断现场后
- 在多种中断的情况下，保护中断现场后

禁止中断即关中断，下列情况应关中断

- 当相应某一级中断请求，不在允许被其他中断请求打断时候
- 在终端服务程序的保护和恢复现场之前

3. 中断屏蔽

- 屏蔽触发器和屏蔽字

中断源发出中断请求后，这个中断请求不一定能真正送到CPU中去，在有些情况下，可以用程序的方式有选择地封锁部分中断，这就是中断屏蔽。

只有当INTRi=1（中断源有中断请求），MASKi=0（该级中断未被屏蔽）时，才允许对应的中断请求送往CPU。

如果一个中断系统有16个中断源，每个中断源按其优先级赋予一个屏蔽字。屏蔽字与中断源的优先级别是一一对应的，0表示开放，1表示屏蔽，则可以制作16个中断源的屏蔽字

- 屏蔽技术和优先等级

### 6.3.3 中断判优

一般可以用软件和硬件两种方式来确定中断源

#### 1.软件查询判优法

#### 2.链式电路判优法

#### 3.编码电路判优法

### 6.3.4 中断向量的形成

CPU一旦响应了I/O中断，就要暂停现行程序，转去执行该设备的中断服务程序。不同的设备有不同的中断服务子程序，每个服务程序都有一个入口地址，CPU必须找到这个入口地址，即中断向量。

## 6.4 DMA方式

DMA方式是在外设和主存之间开辟的一条直接数据链路，在不需要CPU的干预也不需要软件介入的情况下在两者之间进行的高速数据传送方式

### 6.4.1 DMA的工作方式

主存和DMA接口之间有一条数据通路，因此主存和设备交换信息是，不通过CPU，也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场，因此工作速度比程序中断方式高。

此外，若出现高速I/O接口（通过DMA接口）和CPU同时访问主存，CPU必须将总线（如地址线，数据线）占有权让给DMA接口使用，即DMA采用周期窃取的方式占用一个存取周期。

为了有效地分时使用主存，DMA与主存交换数据时通常可采用如下3种方式

#### 1.停止CPU访问主存

当外设要求传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线、数据线和有关控制线的使用权。DMA接口获得线控制权后，开始进行数据传送，在一批数据传送结東后，DMA接口通知CPU可以使用主存，并把总线控制权交还给CPU，在这种DMA传送过程中，CPU基本上处于不工作状态或者保持原状态。

这种方式的优点是控制简单，适用于数据传输率很高的I/O设备实现成组数据的传送。缺点是DMA接口在访存时，内存的效能没有充分发挥，相当一部分内存工作周期是空闲的。因为即使I/O设备高速运行，但其两个数据之间的准备间隔时间也总大于一个存取周期。如软盘读一个8位二进制数大约需要32μs，而半导体存储器的存取周期远远小于1μs，为此在DMA接口中，一般设有一个小容量存储器（这种存储器是半导体芯片制作的），使I/O设备首先与小容量存储器交换数据，然后由小容量存储器与主存交换数据，这便可减少DMA传送数据时占用总线的时间，即可减少CPU的暂停工作时间。

#### 2.周期窃取

在这种方式中，一旦I/O设备发出DMA请求，I/O设备便挪用或窃取总线占用权一个或几个主存周期；而I/O设备没有DMA请求时，CPU仍继续访问主存。

I/O设备要求DMA传送时会遇到以下3种情况:

- 此时CPU不需访间主存，如CPU正在执行乘法指令，由于乘法指今执行时间较长，此时CPU不需访问主存，故I/O设备访存与CPU不发生冲突
- 当I/O设备要求DMA传送时，CPU正在访问主存，此时必须待存取周期结東时，CPU才能将总线占有权让出。
- I/O设备要求访问主存时，CPU也要求访间主存，这就产生了访存冲突。在这种情况下，I/O访存优先于CPU访存，因为I/O访存有时间要求，不立即访问主存就可能丢失数据，这时I/O要窃取1～2个存取周期，意味着CPU在执行访存指令过程中插入了DMA请求，并挪用了1～2个存取周期，使CPU延缓了1～2个存取周期再访问主存。

周期挪用方式尽可能利用CPU不访问主存的间隙进行数据传送，与停止CPU访问主存的方式相比，既实现了I/O传送，又较好地发挥了主存与CPU的效率，是一种广泛采用的方式。

但是，I/O设备每挪用每一个主存周期都要申请总线控制权、建立总线控制权和归还总线控制权，因此，尽管传送一个字对主存而言只占用一个主存周期，但对DMA接口而言，一般要占2～5个主存周期（由逻辑线路的延迟特性而定）。因此，周期挪用的方式比较适合于I/O设备的读写周期大于主存周期的情况。

 #### 3.DMA与CPU交替访存

DMA与CPU交替访存方式是让DMA和CPU分时使用存储总线，即将存储周期分成两部分:一部分专供CPU访存；另一部分专供DMA控制接口访存。两者交替地使用存储总线，互不干扰。这种方式适合于CPU的工作周期比主存存取周期长的情况。例如，CPU的工作周期为1.2μs，主存的存取周期小于0.6μs，那么可将一个CPU周期分为C1和C2两个分周期，其中C1专供DMA访存，C2专供CPU访存

这种方式不需要总线使用权的申请、建立和归还过程，总线使用权是通过C1和C2分时进行的。CPU与DMA接口各自有独立访存地址寄存器、数据寄存器和读写信号等控制寄存器。实际上对于总线，这是在C1和C2控制下的一个多路转换器，其总线控制权的转移几乎不需要什么时间，因而具有很高的DMA传送效率在这种工作方式下，CPU既不停止主程序的运行，也不进入等待状态，在CPU不知不觉中完成了DMA的数据传送，故又有“透明的DMA”方式之称，当然，其相应的硬件逻辑也就变得更为复杂。

### 6.4.2 DMA控制器的功能与组成

#### 1.DMA控制器的功能

利用DMA方式传送数据时，数据传输过程完全由DMA接口电路控制，顾DMA接口又有DMA控制器之称。DMA接口应具有如下几个功能

- 向CPU申请DMA传送
- 在CPU允许DMA工作时，处理总线控制权的转交，避免因进入DMA工作而影响正常活动或引起总线竞争
- 在DMA期间管理系统总线，控制数据传送
- 确定数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度
- 在数据块传送结束时，给出DMA操作完成的信号

#### 2.DMA控制器的基本组成

包括多个设备寄存器，终端控制和DMA逻辑控制等

1. 设备寄存器

主存地址寄存器（MAR）--该寄存器初始值为主存缓冲区的首地址，在传送前由程序送入。

外围设备地址寄存器（ADR）--该寄存器存放I/O设备的设备码，或者表示设备信息储存区的寻址信息

字数计数器（WC）--该计数器对传送数据的总字数进行统计

控制与状态寄存器（CSR）--该寄存器用来存放控制字和状态字

数据缓冲寄存器（DBR）--该寄存器用来暂存I/O接口与主存传送的数据

2. 中断控制逻辑。DMA终端控制逻辑负责申请CPU对DMA进行预处理和后处理
3. DMA控制逻辑。
4. DMA接口与主机和I/O设备两个方向的数据线，地址线和控制信号线以及有关收发和驱动线路

### 6.4.3 DMA数据传送过程

传送前预处理，正式传送，和传送后处理

1. DMA预处理

在DMA接口开始工作之前，CPU必须给它预置如下信息：

- 给DMA控制逻辑知名数据传送方向是输入（主存写）还是输出（主存读）
- 向DMA设备地址寄存器送入设备号，并启动设备
- 向DMA主存地址寄存器送入交换数据的主存起始地址
- 对字计数器赋交换数据的个数

上述工作由CPU执行几条输入输出指令完成，即程序的初始化阶段，这些工作完成后，CPU继续执行和原来的操作

当外部设备准备好发送的数据（输入）或上次接受的数据已经处理完毕（输出）时，他便通过DMA接口向CPU提出占用总线的申请，若有多个DMA同时申请，则按照轻重缓急由硬件排队逻辑决定优先等级。待设备得到总线的控制权后，数据的传送便由该DMA接口进行管理

#### 2.DMA控制I/O设备与主存之间的数据交换

#### 3.CPU中断源程序进行后处理

当DMA的中断请求得到响应后哦，CPU停止源程序的执行，转而去执行中断服务子程序，做一些DMA的结束工作，它包括校验送入主存的数据是否正确；决定是否继续用DMA传送其他数据块，若继续传送，则又要对DMA接口进行初始化。

### 6.4.4 DMA接口与系统的连接方式

#### 1.具有公共请求线的DMA请求方式

若干个DMA接口通过一条公共的DM请求线向CPU申请总线控制权。CPU发出响应信号用链式查询方式通过DMA接口，首先选中的设备获得总线控制权，即可占用总线与主存传送信息。

#### 2.独立的DMA请求方式

每个DMA接口各有一对独立的DMA请求线和DMA响应线，它由CPU优先级判别机构裁决首先响应哪个请求，并在响应线上发出响应信号，被获得响应信号的DMA接口便可控制总线与主存传送数据。

### 6.4.5 DMA的特点

1. 程序中断方式靠程序传送，DMA方式靠硬件传送
2. 从CPU响应时间看，程序中断方式是在一条指令执行结束时响应，而DMA方式可在指令周期内的任意读取周期结束时响应。
3. 程序中断方式有处理异常事件的能力，DMA方式没有这种能力，它主要用于大批数据的传送，如硬盘存取，图像处理，高速数据采集系统
4. 程序中断方式要中断现行程序，故须保护现场，DMA方式不中断现行程序，无须保护现场
5. DMA的优先级比程序中断高

## 6.5 通道控制与外围处理机方式

### 6.5.1 通道的类型

#### 1.采用DMA方式存在的问题

1. 硬件成本高，控制复杂化
2. 会占用CPU部分时间，降低CPU执行程序的程序

#### 2.通道的功能

1. 根据CPU要求选择某一指定外设与系统相连，向该外设发出操作命令，并进行初始化
2. 指出外设读/写信息的位置以及与外设交换信息的主存缓冲区地址
3. 控制外设与主存之间的数据交换，并完成数据字的分拆与装配
4. 制定数据传送结束时的操作内容，并检查外设的状态（良好或有故障）

#### 3.通道的种类

1. 字节多路通道

一种简单的共享通道，主要用于连接大量低速设备，如终端设备。

2. 选择通道

选择通道在物理上可以连接多个设备，但是这些设备不能同时工作，在某一段时间内通道只能选择其中一个设备进行工作，且通道与设备之间的传输一直维持到设备请求传输为止。适合高速传输，连接高速外部设备，如磁盘

3. 成组多路通道

将上面的特点解结合起来，所有子通道共享总通道，又可以用选择通道那样的成组方式高速传输数据

> 例如：有A B C三台设备，传输的数据分别是a1a2a3,b1b2b3,c1c2c3，其中abc各位一个字节

```
a1b1c2a2b2c2...

a1a2a3...amb1b2b3...bmc1c2c3...cm

a1a2...aib1b2...bic1c2...ci
a(i+1)a(i+2)...a(i+j)b(i+1)b(i+2)...b(i+j)c(i+1)c(i+2)...c(i+j)
```