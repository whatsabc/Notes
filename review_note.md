# 1.计算机基本原理
## 1.1储存器
### 1.储存器

#### 1.段定义伪操作
> 完整的段定义伪操作
- SEGMENT/ENDS--段定义伪操作，对此伪操作可以将汇编语言源程序分成几个段，通常是数据段，堆栈段，附加段和代码段
- ASSUME--段指定伪操作：告诉汇编程序，段和段寄存器的对应关系
#### 2.助记符
说明所用伪操作的助记符名称同时也说明所定义的数据段类型，通常为下面的6种
- DB
- DW
- DD
- 重复操作符DUP
- ?操作数：仅仅给变量保留相应的储存空间，而不进行变量赋初值

### 2.储存器分段

#### 1.段：程序员在编制程序时要把存储器划分成段，在每个段内地址空间是线性增长的。段的最大长度为64KB，以便能用16位二进制数表示段内地址。
1). 小段：从0地址开始，每16字节为一小段。小段的首地址用16进制数表示时其最低位为0。

2). 段的起始地址：段不能起始于任意地址，而必须从任一小段(paragraph)的首地址开始。

#### 2.段的类型
- 代码段--用于存放指令，代码段段基址存放在CS
- 数据段--用于存放数据，数据段段基址存放在段寄存器DS
- 附加段--用于辅助存放数据，附加段段基址存放在段寄存器ES
- 堆栈段--是重要的数据结构，可用来保存数据，地址和系统参数，堆栈段段基址存放在段寄存器SS
#### 3.物理地址、段地址、偏移地址、有效地址
1). 物理地址(PA)：在1MB的存储器里，每一个存储单元都有一个唯一的20位地址，称为该存储单元的物理地址(20位)。20位物理地址由16位段地址和16位偏移地址组成。

2). 段地址：段起始地址的高16位值(16位)，低4位固定为0被省去。

3). 偏移地址(偏移量EA)：指在段内相对于段起始地址的偏移值(16位)。

4). 物理地址 = 段地址×10H + 偏移地址。用段地址：偏移地址表示。

5). 有效地址：即操作数的偏移地址
## 1.2 寄存器
### 1.寄存器介绍
#### 1.通用数据寄存器
- 累加器AX
- 基址寄存器BX
- 计数寄存器CX
- 数据寄存器DX

#### 2.地址寄存器
- 堆栈指针SP
- 基址指针BP
- 原变址寄存器SI
- 目的变址寄存器DI
#### 3.段寄存器：在8086~80286中，有4个专门存放段地址的寄存器。
- 代码段CS：存放当前正在运行的程序。
- 数据段DS：存放当前运行程序所用的数据。
- 堆栈段SS：定义堆栈的所在区域。
- 附加段ES：附加的数据段。在80386及其后又增加了FS和GS两个附加数据段寄存器。

---
# 2 常用汇编指令
## 1.数据传送指令
### 1.通用数据传送指令
- MOV 传送指令 
```
指令格式：MOV DST，SRC  ；(DST)←(SRC) DST表示目的操作数, SRC表示源操作数
```
说明：
```
MOV [BX],0
```
是错误的，上面的指令的源操作数是立即数，长度是不确定的，目的操作数是主存单元，但以低地址访问主存单元时，[BX]并不能说明是字单元还是字节单元，因此长度也是不确定的。

为了解决这个问题，可以将代码改成下面的形式：
```
MOV BYTE PTR[BX],0
MOV WORD PTR[BX],0
```
- XCHG交换指令

- PUSH——进栈指令
```
指令格式：PUSH  SRC；16位指令：(SP)←(SP) –2    ((SP)+1,(SP))←(SRC)
```
- POPF/POPFD——标志出栈指令
```
指令格式：
POPF 				；(FLAGS)←((SP)+1,(SP))，(SP)←(SP)+2
POPFD				；(EFLAGS)←((ESP)+3, (ESP)+2, (ESP)+1, (ESP))，
(ESP)←(ESP) -4
```

### 2.地址传送指令 
- LEA——有效地址(EA)送寄存器指令 
```
指令格式：LEA  REG，SRC  ；(REG)←SRC 
```
```
LEA BX,TABLE
MOV BX,OFFSET TABLE
```
上面的指令是等效的
```
LEA BX,[2016H]
MOV BX,OFFSET [2016H]
```

## 2.算术运算指令

### 1.类型扩展指令
- CWB将字节扩展为字
默认将AL寄存器的值扩展到AX，如果AL最高位是1，那么AH=FFH，如果AL最高位是0，AH=00H
- CWD将字扩展为双字
默认将AX寄存器的值扩展到DX,AX,如果AX最高位是1，那么DX=FFFFH，如果AX最高位是0，DX=0000H

### 2.加法指令 
- ADD——加法指令 
```
指令格式：ADD  DST，SRC  ；(DST)←(DST)+(SRC)
```
- ADC带进位加法
- INC加一
### 3.减法指令 
- SUB——减法指令
```
指令格式：SUB  DST，SRC  ；(DST)←(DST)-(SRC)
```
- SBB——带借位减法指令
```
指令格式：SBB  DST，SRC   ；(DST)←(DST)-(SRC)-CF
```

### 3.乘法指令
- MUL无符号数乘法
- IMUL有符号数乘法
### 4.除法指令
- DIV——无符号数除法指令 
```
指令格式：DIV SRC
```
字节操作：
```
(AL)←(AX)/(SRC)，(AH)←(AX)%(SRC)
```
字操作：
```
(AX)←(DX,AX)/(SRC)，(DX)←(DX,AX)%(SRC)
```

## 3.逻辑与移位指令

### 1.逻辑运算指令：可以对双字、字或字节执行按位的逻辑运算。
- AND——逻辑与指令
```
指令格式：AND  DST，SRC		；(DST)←(DST)∧(SRC)
```
- OR——逻辑或指令
```
指令格式：OR  DST，SRC		；(DST)←(DST)∨(SRC)
```
- XOR——逻辑异或指令
```
指令格式：XOR  DST，SRC		；(DST)←(DST)⊕(SRC)
```
- TEST——测试指令
```
指令格式：TEST  OPR1，OPR2   ；(OPR1)∧(OPR2)
```
说明：①.DST、OPR、OPR1不允许使用立即数寻址方式。


### 2.移位指令

- SHL——逻辑左移指令
```
指令格式：SHL  OPR，CNT
```
- SAL——算术左移指令
```
指令格式：SAL  OPR，CNT		；同上
```
- SHR——逻辑右移指令
```
指令格式：SHR  OPR，CNT
```
- SAR——算术右移指令
```
指令格式：SAR  OPR，CNT
```
### 3.循环移位指令
- ROR——循环右移指令
```
指令格式：ROR  OPR，CNT
```
- RCR——带进位位循环右移指令
```
指令格式：RCR  OPR，CNT
```
说明：
①.OPR为除立即数以外的任意寻址方式。移位次数由CL提供

②.CF位已在指令中给出其影响情况

## 4.串操作指令
### 1.MOVS串传送指令
- MOVSB
- MOVSW
- MOVS
实际上MOVS指令的寻址方式是固定的，目的串地址为ES:[DI]，原串地址为DS:[SI]
```
MOVS ES:BYTE PTR[DI],DS:[SI]
```
下面介绍前两种格式的操作
### 2.CMPS
### 3.SCAS
### 4.STOS
### 5.LODS
